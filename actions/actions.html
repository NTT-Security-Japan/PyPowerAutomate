<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pypowerautomate.actions.actions API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pypowerautomate.actions.actions</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import json
from typing import List, Dict, Union
from copy import deepcopy
from .base import BaseAction, SkeltonNode
from .variable import InitVariableAction


class Actions:
    &#34;&#34;&#34;
    A class that aggregates action nodes into a tree structure, corresponding to the &#39;Actions&#39; field in a JSON schema.

    This class defines a tree structure with the following constraints:
    - The root node is always a SkeletonNode and is not included in exports.
    - All nodes, except for the root, must have exactly one parent node.
    - Nodes can have zero or more child nodes.

    Note:
    To manage variable initialization actions at the top of the chain in flows triggered by events, such actions are only allowed at the root level and must be executed in sequence before other actions.
    &#34;&#34;&#34;

    def __init__(self, is_root: bool = False) -&gt; None:
        self.root_node = SkeltonNode(&#34;root&#34;)
        self.last_update_node = self.root_node
        self.is_root_actions: bool = is_root
        self.nodes: Dict[str, BaseAction] = {&#34;root&#34;: self.root_node}
        self.variable_init_nodes: List[BaseAction] = []

    def __validate_action(self, new_action: BaseAction, prev_action: BaseAction = None):
        &#34;&#34;&#34;
        Validates a new action before adding it to the tree, ensuring it does not already exist, and checks parent-child constraints.

        Args:
            new_action (BaseAction): The action to be validated.
            prev_action (BaseAction): The previous action in the tree to which the new action would be linked.
        
        Raises:
            ValueError: If the action violates any constraints.
        &#34;&#34;&#34;
        if new_action in self.nodes.values():
            raise ValueError(f&#34;{new_action} already exists in Actions&#34;)
        if new_action.have_parent_node:
            raise ValueError(f&#34;{new_action} already have a parent Actions.&#34;)
        if prev_action and prev_action not in self.nodes.values():
            raise ValueError(f&#34;{prev_action} not in Actions&#34;)
        if not self.is_root_actions and isinstance(new_action, InitVariableAction):
            raise ValueError(f&#34;{new_action} cannot be set into non-root Actions&#34;)

        original_name = new_action.action_name
        counter = 1
        while new_action.action_name in self.nodes:
            new_action.action_name = f&#34;{original_name}_{counter}&#34;
            counter += 1

    def add_top(self, new_action: BaseAction):
        &#34;&#34;&#34;
        Adds a new action at the top of the tree under the root node.

        Args:
            new_action (BaseAction): The action to be added.
        &#34;&#34;&#34;
        self.__validate_action(new_action)
        self.root_node.add_next_action(new_action)
        new_action.have_parent_node = True
        new_action.update_runafter(self.root_node)
        self.last_update_node = new_action
        self.nodes[new_action.action_name] = new_action

    def add_after(self, new_action: BaseAction, prev_action: BaseAction, force_exec: bool = False, exec_if_failed: bool = False):
        &#34;&#34;&#34;
        Adds a new action immediately after a specified action in the tree.

        Args:
            new_action (BaseAction): The action to be added.
            prev_action (BaseAction): The action after which the new action should be added.
            force_exec (bool): If true, the new action will execute even if the previous action failed.
            exec_if_failed (bool): If true, the new action will execute only if the previous action failed.
        &#34;&#34;&#34;
        self.__validate_action(new_action, prev_action)
        prev_action.add_next_action(new_action)
        new_action.have_parent_node = True
        new_action.update_runafter(prev_action, force_exec=force_exec, exec_if_failed=exec_if_failed)
        self.last_update_node = new_action
        self.nodes[new_action.action_name] = new_action

    def append(self, new_action: BaseAction, force_exec: bool = False, exec_if_failed: bool = False):
        &#34;&#34;&#34;
        Appends a new action to the last updated node in the tree.

        Args:
            new_action (BaseAction): The action to be added.
            force_exec (bool): If true, the new action will execute regardless of the previous action&#39;s success.
            exec_if_failed (bool): If true, the new action will execute only if the previous action failed.
        &#34;&#34;&#34;
        self.__validate_action(new_action)
        self.last_update_node.add_next_action(new_action)
        new_action.have_parent_node = True
        new_action.update_runafter(self.last_update_node, force_exec=force_exec, exec_if_failed=exec_if_failed)
        self.last_update_node = new_action
        self.nodes[new_action.action_name] = new_action

    def copy_nodes(self, original_node: BaseAction) -&gt; BaseAction:
        &#34;&#34;&#34;
        Recursively copies a node and all its children.

        Args:
            original_node (BaseAction): The root node from which the copy will begin.

        Returns:
            BaseAction: The root of the copied subtree.
        &#34;&#34;&#34;
        new_node = original_node.clone()
        for child in original_node.next_nodes:
            new_child = self.copy_nodes(child)
            new_node.add_next_action(new_child)
        return new_node

    def __deepcopy__(self, memo) -&gt; &#39;Actions&#39;:
        &#34;&#34;&#34;
        Creates a deep copy of this Actions instance, including all nodes and their connections.

        Returns:
            Actions: A new Actions instance that is a deep copy of this instance.
        &#34;&#34;&#34;
        new_root = self.copy_nodes(self.root_node)
        new_actions = Actions(self.is_root_actions)
        new_actions.root_node = new_root
        new_actions.nodes = {&#34;root&#34;: new_root}
        stack = [(new_root, None)]
        while stack:
            child, parent = stack.pop()
            if parent:
                new_actions.add_after(child, parent)
            for next_node in child.next_nodes:
                stack.append((next_node, child))
        new_actions.last_update_node = new_actions.nodes[self.last_update_node.action_name]
        return new_actions

    def clone(self) -&gt; &#39;Actions&#39;:
        &#34;&#34;&#34;
        Creates a clone of this Actions instance using deep copy.

        Returns:
            Actions: A cloned instance of this Actions.
        &#34;&#34;&#34;
        return deepcopy(self)

    def __add__(self, rhs_actions: Union[&#39;Actions&#39;, BaseAction]) -&gt; &#39;Actions&#39;:
        &#34;&#34;&#34;
        Supports the addition of another Actions instance or a BaseAction to this instance, combining their nodes appropriately.

        Args:
            rhs_actions (Union[&#39;Actions&#39;, BaseAction]): The right-hand side Actions instance or BaseAction to add.

        Returns:
            Actions: A new Actions instance resulting from the addition.

        Raises:
            TypeError: If the right-hand side is neither an Actions instance nor a BaseAction.
        &#34;&#34;&#34;
        if isinstance(rhs_actions, Actions):
            new_actions = self.clone()
            new_actions.is_root_actions |= rhs_actions.is_root_actions
            stack = [(rhs_actions.root_node, None)]
            while stack:
                child, parent = stack.pop()
                new_child = child.clone()
                for next_node in child.next_nodes:
                    if isinstance(new_child, SkeltonNode):
                        stack.append((next_node, new_actions.last_update_node))
                    else:
                        stack.append((next_node, new_child))
                if not isinstance(new_child, SkeltonNode):
                    new_actions.add_after(new_child, parent)
            return new_actions
        elif isinstance(rhs_actions, BaseAction):
            new_actions = self.clone()
            new_actions.append(rhs_actions.clone())
            return new_actions
        raise TypeError(&#34;Both operand must be instance of the Actions class or BaseAction&#34;)

    def export(self) -&gt; Dict:
        &#34;&#34;&#34;
        Exports the Actions tree to a dictionary, excluding the root node.

        Returns:
            Dict: A dictionary representation of all actions except the root.
        &#34;&#34;&#34;
        d = {}
        for node in self.nodes.values():
            if isinstance(node, SkeltonNode):
                continue
            d[node.action_name] = node.export()
        return d


class RawActions:
    &#34;&#34;&#34;
    A class that behaves like the Actions class but takes exported data as input and re-validates it.

    Args:
        definition (Dict): A dictionary representation of actions.
    &#34;&#34;&#34;

    def __init__(self, definition: Dict):
        self.definition: Dict = definition
    
    def validation(self) -&gt; bool:
        &#34;&#34;&#34;
        Validates the structure of the actions dictionary, ensuring each action has required properties and there are no duplicate names or unresolved dependencies.

        Returns:
            bool: True if the dictionary is valid, False otherwise.
        &#34;&#34;&#34;
        if not self.definition:
            return False
        used_names = set()
        for action_name, node in self.definition.items():
            if action_name in used_names:
                return False
            used_names.add(action_name)
            if not isinstance(node, dict) or {&#34;type&#34;, &#34;inputs&#34;, &#34;metadata&#34;} - node.keys():
                return False
            if &#34;runAfter&#34; in node and any(name not in used_names for name in node[&#34;runAfter&#34;]):
                return False
        return True

    def export(self) -&gt; Dict:
        &#34;&#34;&#34;
        Re-exports the actions dictionary if it passes validation, otherwise returns an empty dictionary.

        Returns:
            Dict: The validated actions dictionary, or an empty dictionary if validation fails.
        &#34;&#34;&#34;
        return self.definition if self.validation() else {}</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pypowerautomate.actions.actions.Actions"><code class="flex name class">
<span>class <span class="ident">Actions</span></span>
<span>(</span><span>is_root: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>A class that aggregates action nodes into a tree structure, corresponding to the 'Actions' field in a JSON schema.</p>
<p>This class defines a tree structure with the following constraints:
- The root node is always a SkeletonNode and is not included in exports.
- All nodes, except for the root, must have exactly one parent node.
- Nodes can have zero or more child nodes.</p>
<p>Note:
To manage variable initialization actions at the top of the chain in flows triggered by events, such actions are only allowed at the root level and must be executed in sequence before other actions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Actions:
    &#34;&#34;&#34;
    A class that aggregates action nodes into a tree structure, corresponding to the &#39;Actions&#39; field in a JSON schema.

    This class defines a tree structure with the following constraints:
    - The root node is always a SkeletonNode and is not included in exports.
    - All nodes, except for the root, must have exactly one parent node.
    - Nodes can have zero or more child nodes.

    Note:
    To manage variable initialization actions at the top of the chain in flows triggered by events, such actions are only allowed at the root level and must be executed in sequence before other actions.
    &#34;&#34;&#34;

    def __init__(self, is_root: bool = False) -&gt; None:
        self.root_node = SkeltonNode(&#34;root&#34;)
        self.last_update_node = self.root_node
        self.is_root_actions: bool = is_root
        self.nodes: Dict[str, BaseAction] = {&#34;root&#34;: self.root_node}
        self.variable_init_nodes: List[BaseAction] = []

    def __validate_action(self, new_action: BaseAction, prev_action: BaseAction = None):
        &#34;&#34;&#34;
        Validates a new action before adding it to the tree, ensuring it does not already exist, and checks parent-child constraints.

        Args:
            new_action (BaseAction): The action to be validated.
            prev_action (BaseAction): The previous action in the tree to which the new action would be linked.
        
        Raises:
            ValueError: If the action violates any constraints.
        &#34;&#34;&#34;
        if new_action in self.nodes.values():
            raise ValueError(f&#34;{new_action} already exists in Actions&#34;)
        if new_action.have_parent_node:
            raise ValueError(f&#34;{new_action} already have a parent Actions.&#34;)
        if prev_action and prev_action not in self.nodes.values():
            raise ValueError(f&#34;{prev_action} not in Actions&#34;)
        if not self.is_root_actions and isinstance(new_action, InitVariableAction):
            raise ValueError(f&#34;{new_action} cannot be set into non-root Actions&#34;)

        original_name = new_action.action_name
        counter = 1
        while new_action.action_name in self.nodes:
            new_action.action_name = f&#34;{original_name}_{counter}&#34;
            counter += 1

    def add_top(self, new_action: BaseAction):
        &#34;&#34;&#34;
        Adds a new action at the top of the tree under the root node.

        Args:
            new_action (BaseAction): The action to be added.
        &#34;&#34;&#34;
        self.__validate_action(new_action)
        self.root_node.add_next_action(new_action)
        new_action.have_parent_node = True
        new_action.update_runafter(self.root_node)
        self.last_update_node = new_action
        self.nodes[new_action.action_name] = new_action

    def add_after(self, new_action: BaseAction, prev_action: BaseAction, force_exec: bool = False, exec_if_failed: bool = False):
        &#34;&#34;&#34;
        Adds a new action immediately after a specified action in the tree.

        Args:
            new_action (BaseAction): The action to be added.
            prev_action (BaseAction): The action after which the new action should be added.
            force_exec (bool): If true, the new action will execute even if the previous action failed.
            exec_if_failed (bool): If true, the new action will execute only if the previous action failed.
        &#34;&#34;&#34;
        self.__validate_action(new_action, prev_action)
        prev_action.add_next_action(new_action)
        new_action.have_parent_node = True
        new_action.update_runafter(prev_action, force_exec=force_exec, exec_if_failed=exec_if_failed)
        self.last_update_node = new_action
        self.nodes[new_action.action_name] = new_action

    def append(self, new_action: BaseAction, force_exec: bool = False, exec_if_failed: bool = False):
        &#34;&#34;&#34;
        Appends a new action to the last updated node in the tree.

        Args:
            new_action (BaseAction): The action to be added.
            force_exec (bool): If true, the new action will execute regardless of the previous action&#39;s success.
            exec_if_failed (bool): If true, the new action will execute only if the previous action failed.
        &#34;&#34;&#34;
        self.__validate_action(new_action)
        self.last_update_node.add_next_action(new_action)
        new_action.have_parent_node = True
        new_action.update_runafter(self.last_update_node, force_exec=force_exec, exec_if_failed=exec_if_failed)
        self.last_update_node = new_action
        self.nodes[new_action.action_name] = new_action

    def copy_nodes(self, original_node: BaseAction) -&gt; BaseAction:
        &#34;&#34;&#34;
        Recursively copies a node and all its children.

        Args:
            original_node (BaseAction): The root node from which the copy will begin.

        Returns:
            BaseAction: The root of the copied subtree.
        &#34;&#34;&#34;
        new_node = original_node.clone()
        for child in original_node.next_nodes:
            new_child = self.copy_nodes(child)
            new_node.add_next_action(new_child)
        return new_node

    def __deepcopy__(self, memo) -&gt; &#39;Actions&#39;:
        &#34;&#34;&#34;
        Creates a deep copy of this Actions instance, including all nodes and their connections.

        Returns:
            Actions: A new Actions instance that is a deep copy of this instance.
        &#34;&#34;&#34;
        new_root = self.copy_nodes(self.root_node)
        new_actions = Actions(self.is_root_actions)
        new_actions.root_node = new_root
        new_actions.nodes = {&#34;root&#34;: new_root}
        stack = [(new_root, None)]
        while stack:
            child, parent = stack.pop()
            if parent:
                new_actions.add_after(child, parent)
            for next_node in child.next_nodes:
                stack.append((next_node, child))
        new_actions.last_update_node = new_actions.nodes[self.last_update_node.action_name]
        return new_actions

    def clone(self) -&gt; &#39;Actions&#39;:
        &#34;&#34;&#34;
        Creates a clone of this Actions instance using deep copy.

        Returns:
            Actions: A cloned instance of this Actions.
        &#34;&#34;&#34;
        return deepcopy(self)

    def __add__(self, rhs_actions: Union[&#39;Actions&#39;, BaseAction]) -&gt; &#39;Actions&#39;:
        &#34;&#34;&#34;
        Supports the addition of another Actions instance or a BaseAction to this instance, combining their nodes appropriately.

        Args:
            rhs_actions (Union[&#39;Actions&#39;, BaseAction]): The right-hand side Actions instance or BaseAction to add.

        Returns:
            Actions: A new Actions instance resulting from the addition.

        Raises:
            TypeError: If the right-hand side is neither an Actions instance nor a BaseAction.
        &#34;&#34;&#34;
        if isinstance(rhs_actions, Actions):
            new_actions = self.clone()
            new_actions.is_root_actions |= rhs_actions.is_root_actions
            stack = [(rhs_actions.root_node, None)]
            while stack:
                child, parent = stack.pop()
                new_child = child.clone()
                for next_node in child.next_nodes:
                    if isinstance(new_child, SkeltonNode):
                        stack.append((next_node, new_actions.last_update_node))
                    else:
                        stack.append((next_node, new_child))
                if not isinstance(new_child, SkeltonNode):
                    new_actions.add_after(new_child, parent)
            return new_actions
        elif isinstance(rhs_actions, BaseAction):
            new_actions = self.clone()
            new_actions.append(rhs_actions.clone())
            return new_actions
        raise TypeError(&#34;Both operand must be instance of the Actions class or BaseAction&#34;)

    def export(self) -&gt; Dict:
        &#34;&#34;&#34;
        Exports the Actions tree to a dictionary, excluding the root node.

        Returns:
            Dict: A dictionary representation of all actions except the root.
        &#34;&#34;&#34;
        d = {}
        for node in self.nodes.values():
            if isinstance(node, SkeltonNode):
                continue
            d[node.action_name] = node.export()
        return d</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pypowerautomate.actions.actions.Actions.add_after"><code class="name flex">
<span>def <span class="ident">add_after</span></span>(<span>self, new_action: <a title="pypowerautomate.actions.base.BaseAction" href="base.html#pypowerautomate.actions.base.BaseAction">BaseAction</a>, prev_action: <a title="pypowerautomate.actions.base.BaseAction" href="base.html#pypowerautomate.actions.base.BaseAction">BaseAction</a>, force_exec: bool = False, exec_if_failed: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a new action immediately after a specified action in the tree.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>new_action</code></strong> :&ensp;<code>BaseAction</code></dt>
<dd>The action to be added.</dd>
<dt><strong><code>prev_action</code></strong> :&ensp;<code>BaseAction</code></dt>
<dd>The action after which the new action should be added.</dd>
<dt><strong><code>force_exec</code></strong> :&ensp;<code>bool</code></dt>
<dd>If true, the new action will execute even if the previous action failed.</dd>
<dt><strong><code>exec_if_failed</code></strong> :&ensp;<code>bool</code></dt>
<dd>If true, the new action will execute only if the previous action failed.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_after(self, new_action: BaseAction, prev_action: BaseAction, force_exec: bool = False, exec_if_failed: bool = False):
    &#34;&#34;&#34;
    Adds a new action immediately after a specified action in the tree.

    Args:
        new_action (BaseAction): The action to be added.
        prev_action (BaseAction): The action after which the new action should be added.
        force_exec (bool): If true, the new action will execute even if the previous action failed.
        exec_if_failed (bool): If true, the new action will execute only if the previous action failed.
    &#34;&#34;&#34;
    self.__validate_action(new_action, prev_action)
    prev_action.add_next_action(new_action)
    new_action.have_parent_node = True
    new_action.update_runafter(prev_action, force_exec=force_exec, exec_if_failed=exec_if_failed)
    self.last_update_node = new_action
    self.nodes[new_action.action_name] = new_action</code></pre>
</details>
</dd>
<dt id="pypowerautomate.actions.actions.Actions.add_top"><code class="name flex">
<span>def <span class="ident">add_top</span></span>(<span>self, new_action: <a title="pypowerautomate.actions.base.BaseAction" href="base.html#pypowerautomate.actions.base.BaseAction">BaseAction</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a new action at the top of the tree under the root node.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>new_action</code></strong> :&ensp;<code>BaseAction</code></dt>
<dd>The action to be added.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_top(self, new_action: BaseAction):
    &#34;&#34;&#34;
    Adds a new action at the top of the tree under the root node.

    Args:
        new_action (BaseAction): The action to be added.
    &#34;&#34;&#34;
    self.__validate_action(new_action)
    self.root_node.add_next_action(new_action)
    new_action.have_parent_node = True
    new_action.update_runafter(self.root_node)
    self.last_update_node = new_action
    self.nodes[new_action.action_name] = new_action</code></pre>
</details>
</dd>
<dt id="pypowerautomate.actions.actions.Actions.append"><code class="name flex">
<span>def <span class="ident">append</span></span>(<span>self, new_action: <a title="pypowerautomate.actions.base.BaseAction" href="base.html#pypowerautomate.actions.base.BaseAction">BaseAction</a>, force_exec: bool = False, exec_if_failed: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Appends a new action to the last updated node in the tree.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>new_action</code></strong> :&ensp;<code>BaseAction</code></dt>
<dd>The action to be added.</dd>
<dt><strong><code>force_exec</code></strong> :&ensp;<code>bool</code></dt>
<dd>If true, the new action will execute regardless of the previous action's success.</dd>
<dt><strong><code>exec_if_failed</code></strong> :&ensp;<code>bool</code></dt>
<dd>If true, the new action will execute only if the previous action failed.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append(self, new_action: BaseAction, force_exec: bool = False, exec_if_failed: bool = False):
    &#34;&#34;&#34;
    Appends a new action to the last updated node in the tree.

    Args:
        new_action (BaseAction): The action to be added.
        force_exec (bool): If true, the new action will execute regardless of the previous action&#39;s success.
        exec_if_failed (bool): If true, the new action will execute only if the previous action failed.
    &#34;&#34;&#34;
    self.__validate_action(new_action)
    self.last_update_node.add_next_action(new_action)
    new_action.have_parent_node = True
    new_action.update_runafter(self.last_update_node, force_exec=force_exec, exec_if_failed=exec_if_failed)
    self.last_update_node = new_action
    self.nodes[new_action.action_name] = new_action</code></pre>
</details>
</dd>
<dt id="pypowerautomate.actions.actions.Actions.clone"><code class="name flex">
<span>def <span class="ident">clone</span></span>(<span>self) ‑> <a title="pypowerautomate.actions.actions.Actions" href="#pypowerautomate.actions.actions.Actions">Actions</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates a clone of this Actions instance using deep copy.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="pypowerautomate.actions.actions.Actions" href="#pypowerautomate.actions.actions.Actions">Actions</a></code></dt>
<dd>A cloned instance of this Actions.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clone(self) -&gt; &#39;Actions&#39;:
    &#34;&#34;&#34;
    Creates a clone of this Actions instance using deep copy.

    Returns:
        Actions: A cloned instance of this Actions.
    &#34;&#34;&#34;
    return deepcopy(self)</code></pre>
</details>
</dd>
<dt id="pypowerautomate.actions.actions.Actions.copy_nodes"><code class="name flex">
<span>def <span class="ident">copy_nodes</span></span>(<span>self, original_node: <a title="pypowerautomate.actions.base.BaseAction" href="base.html#pypowerautomate.actions.base.BaseAction">BaseAction</a>) ‑> <a title="pypowerautomate.actions.base.BaseAction" href="base.html#pypowerautomate.actions.base.BaseAction">BaseAction</a></span>
</code></dt>
<dd>
<div class="desc"><p>Recursively copies a node and all its children.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>original_node</code></strong> :&ensp;<code>BaseAction</code></dt>
<dd>The root node from which the copy will begin.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>BaseAction</code></dt>
<dd>The root of the copied subtree.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy_nodes(self, original_node: BaseAction) -&gt; BaseAction:
    &#34;&#34;&#34;
    Recursively copies a node and all its children.

    Args:
        original_node (BaseAction): The root node from which the copy will begin.

    Returns:
        BaseAction: The root of the copied subtree.
    &#34;&#34;&#34;
    new_node = original_node.clone()
    for child in original_node.next_nodes:
        new_child = self.copy_nodes(child)
        new_node.add_next_action(new_child)
    return new_node</code></pre>
</details>
</dd>
<dt id="pypowerautomate.actions.actions.Actions.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Exports the Actions tree to a dictionary, excluding the root node.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict</code></dt>
<dd>A dictionary representation of all actions except the root.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self) -&gt; Dict:
    &#34;&#34;&#34;
    Exports the Actions tree to a dictionary, excluding the root node.

    Returns:
        Dict: A dictionary representation of all actions except the root.
    &#34;&#34;&#34;
    d = {}
    for node in self.nodes.values():
        if isinstance(node, SkeltonNode):
            continue
        d[node.action_name] = node.export()
    return d</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pypowerautomate.actions.actions.RawActions"><code class="flex name class">
<span>class <span class="ident">RawActions</span></span>
<span>(</span><span>definition: Dict)</span>
</code></dt>
<dd>
<div class="desc"><p>A class that behaves like the Actions class but takes exported data as input and re-validates it.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>definition</code></strong> :&ensp;<code>Dict</code></dt>
<dd>A dictionary representation of actions.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RawActions:
    &#34;&#34;&#34;
    A class that behaves like the Actions class but takes exported data as input and re-validates it.

    Args:
        definition (Dict): A dictionary representation of actions.
    &#34;&#34;&#34;

    def __init__(self, definition: Dict):
        self.definition: Dict = definition
    
    def validation(self) -&gt; bool:
        &#34;&#34;&#34;
        Validates the structure of the actions dictionary, ensuring each action has required properties and there are no duplicate names or unresolved dependencies.

        Returns:
            bool: True if the dictionary is valid, False otherwise.
        &#34;&#34;&#34;
        if not self.definition:
            return False
        used_names = set()
        for action_name, node in self.definition.items():
            if action_name in used_names:
                return False
            used_names.add(action_name)
            if not isinstance(node, dict) or {&#34;type&#34;, &#34;inputs&#34;, &#34;metadata&#34;} - node.keys():
                return False
            if &#34;runAfter&#34; in node and any(name not in used_names for name in node[&#34;runAfter&#34;]):
                return False
        return True

    def export(self) -&gt; Dict:
        &#34;&#34;&#34;
        Re-exports the actions dictionary if it passes validation, otherwise returns an empty dictionary.

        Returns:
            Dict: The validated actions dictionary, or an empty dictionary if validation fails.
        &#34;&#34;&#34;
        return self.definition if self.validation() else {}</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pypowerautomate.actions.actions.RawActions.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Re-exports the actions dictionary if it passes validation, otherwise returns an empty dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict</code></dt>
<dd>The validated actions dictionary, or an empty dictionary if validation fails.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self) -&gt; Dict:
    &#34;&#34;&#34;
    Re-exports the actions dictionary if it passes validation, otherwise returns an empty dictionary.

    Returns:
        Dict: The validated actions dictionary, or an empty dictionary if validation fails.
    &#34;&#34;&#34;
    return self.definition if self.validation() else {}</code></pre>
</details>
</dd>
<dt id="pypowerautomate.actions.actions.RawActions.validation"><code class="name flex">
<span>def <span class="ident">validation</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Validates the structure of the actions dictionary, ensuring each action has required properties and there are no duplicate names or unresolved dependencies.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if the dictionary is valid, False otherwise.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validation(self) -&gt; bool:
    &#34;&#34;&#34;
    Validates the structure of the actions dictionary, ensuring each action has required properties and there are no duplicate names or unresolved dependencies.

    Returns:
        bool: True if the dictionary is valid, False otherwise.
    &#34;&#34;&#34;
    if not self.definition:
        return False
    used_names = set()
    for action_name, node in self.definition.items():
        if action_name in used_names:
            return False
        used_names.add(action_name)
        if not isinstance(node, dict) or {&#34;type&#34;, &#34;inputs&#34;, &#34;metadata&#34;} - node.keys():
            return False
        if &#34;runAfter&#34; in node and any(name not in used_names for name in node[&#34;runAfter&#34;]):
            return False
    return True</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pypowerautomate.actions" href="index.html">pypowerautomate.actions</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pypowerautomate.actions.actions.Actions" href="#pypowerautomate.actions.actions.Actions">Actions</a></code></h4>
<ul class="two-column">
<li><code><a title="pypowerautomate.actions.actions.Actions.add_after" href="#pypowerautomate.actions.actions.Actions.add_after">add_after</a></code></li>
<li><code><a title="pypowerautomate.actions.actions.Actions.add_top" href="#pypowerautomate.actions.actions.Actions.add_top">add_top</a></code></li>
<li><code><a title="pypowerautomate.actions.actions.Actions.append" href="#pypowerautomate.actions.actions.Actions.append">append</a></code></li>
<li><code><a title="pypowerautomate.actions.actions.Actions.clone" href="#pypowerautomate.actions.actions.Actions.clone">clone</a></code></li>
<li><code><a title="pypowerautomate.actions.actions.Actions.copy_nodes" href="#pypowerautomate.actions.actions.Actions.copy_nodes">copy_nodes</a></code></li>
<li><code><a title="pypowerautomate.actions.actions.Actions.export" href="#pypowerautomate.actions.actions.Actions.export">export</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pypowerautomate.actions.actions.RawActions" href="#pypowerautomate.actions.actions.RawActions">RawActions</a></code></h4>
<ul class="">
<li><code><a title="pypowerautomate.actions.actions.RawActions.export" href="#pypowerautomate.actions.actions.RawActions.export">export</a></code></li>
<li><code><a title="pypowerautomate.actions.actions.RawActions.validation" href="#pypowerautomate.actions.actions.RawActions.validation">validation</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>